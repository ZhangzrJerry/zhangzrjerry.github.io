<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>二维卡尔曼滤波器</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)'], ['$', '$']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 3fr 2fr;
            gap: 20px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-container {
            height: 450px;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
        }

        .plot-canvas {
            height: 220px;
            margin-top: 12px;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 14px;
        }

        .btn-init {
            background: #4285f4;
            color: white;
        }

        .btn-step {
            background: #2ecc71;
            color: white;
        }

        .btn-reset {
            background: #ea4335;
            color: white;
        }

        .btn-disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #step-indicator {
            font-size: 18px;
            font-weight: bold;
            color: #4285f4;
            margin: 10px 0;
        }

        .param-panel {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
        }

        .param-group {
            margin: 15px 0;
        }

        .param-item {
            margin: 8px 0;
        }

        .calc-panel {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            height: calc(100% - 32px);
            overflow-y: auto;
        }

        .calc-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .calc-step {
            margin: 12px 0;
            padding-left: 10px;
            border-left: 3px solid #4285f4;
        }

        .calc-formula {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 8px 0;
        }

        .state-label {
            display: inline-block;
            width: 80px;
        }
    </style>
</head>

<body>
    <h1>二维卡尔曼滤波器</h1>
    <div id="step-indicator">当前步骤：1. 初始化参数与系统真实状态</div>

    <div class="container">
        <!-- 左侧：控制区 + 可视化图表 -->
        <div class="left-panel">
            <!-- 控制按钮 -->
            <div>
                <button id="init-btn" class="control-btn btn-init">1. 初始化系统</button>
                <button id="predict-btn" class="control-btn btn-step btn-disabled" disabled>2. 预测二维状态</button>
                <button id="measure-btn" class="control-btn btn-step btn-disabled" disabled>3. 生成二维测量值</button>
                <button id="update-btn" class="control-btn btn-step btn-disabled" disabled>4. 更新状态估计</button>
                <button id="reset-btn" class="control-btn btn-reset">重置演示</button>
            </div>

            <!-- 参数调节区 -->
            <div class="param-panel">
                <h3>核心参数调节</h3>
                <div class="param-group">
                    <div class="param-item">
                        <label>过程噪声方差 Q：</label>
                        <input type="number" id="q-input" value="0.05" step="0.01" min="0.01" max="0.5">
                        <span>（系统运动的随机扰动）</span>
                    </div>
                    <div class="param-item">
                        <label>测量噪声方差 R：</label>
                        <input type="number" id="r-input" value="0.01" step="0.001" min="0.01" max="1">
                        <span>（传感器测量误差）</span>
                    </div>
                    <div class="param-item">
                        <label>初始估计方差 P₀：</label>
                        <input type="number" id="p0-input" value="1.0" step="0.1" min="0.1" max="5">
                        <span>（初始估计的不确定性）</span>
                    </div>
                </div>
            </div>

            <!-- 二维状态可视化图表 -->
            <div class="chart-container">
                <canvas id="2d-kalman-chart"></canvas>
                <canvas id="plot-chart" class="plot-canvas"></canvas>
            </div>
        </div>

        <!-- 右侧：实时计算过程展示 -->
        <div class="calc-panel">
            <div class="calc-title">📝 实时计算过程（x坐标 + y坐标）</div>
            <div id="calc-content">
                <p>点击「1. 初始化系统」开始演示。每步会展示简洁、可读的卡尔曼滤波计算公式及对应的数值结果（本示例将 \\(A=I_2、H=I_2\\) 简化为单位矩阵）。</p>
                <div class="calc-formula">\(\text{预测 (Predict):}\)
                    <br>
                    \[\hat{x}_k^- = A\hat{x}_{k-1}\]
                    <br>
                    \[P_k^- = A P_{k-1} A^T + Q\]
                </div>
                <div class="calc-formula">\(\text{更新 (Update):}\)
                    <br>
                    \[K_k = P_k^- H^T (H P_k^- H^T + R)^{-1}\]
                    <br>
                    \[\hat{x}_k = \hat{x}_k^- + K_k (z_k - H\hat{x}_k^-)\]
                    <br>
                    \[P_k = (I - K_k H) P_k^-\]
                </div>
            </div>
        </div>
    </div>

    <script>
        // 1. 全局状态变量（二维：x和y坐标）
        let trueState = { x: 0, y: 0 };       // 系统真实状态 (x,y)
        let estimatedState = { x: 0, y: 0 };  // 卡尔曼估计状态
        let errorCovariance = 1;              // 估计误差方差 P（二维共用，简化为标量）
        let processNoise = 0.05;              // 过程噪声方差 Q
        let measureNoise = 0.2;               // 测量噪声方差 R
        let measurements = [];                // 测量值历史 [{x,y}, ...]
        let estimates = [];                   // 估计值历史 [{x,y}, ...]
        let predictions = [];                 // 预测值历史 [{x,y}, ...]
        let trueStates = [];                  // 真实状态历史 [{x,y}, ...]
        let currentStep = 0;                  // 0-未初始化，1-可预测，2-可测量，3-可更新
        let chart = null;                     // 图表实例
        let plotChart = null;                 // Pk / dxk 折线图实例
        let pHistory = [];                    // P_k (post-update) 历史
        // let dxHistory = [];                    // dx_k (innovation norm) 历史
        let lastResidual = 0;                 // 临时保存最近一次生成的残差（在测量步骤计算）
        let stepLabels = [];                  // x 轴标签（步号）
        let cycleIndex = 0;                   // 完整循环计数（每次update后+1）
        // 圆轨迹参数（真实状态沿圆运动）
        let circleAngle = 0;                  // 当前角度（弧度）
        let circleRadius = 6;                 // 圆半径
        let angularSpeed = Math.PI / 18;      // 每次预测角度增量（弧度），默认为10度

        // 2. 初始化二维散点图（x轴为x坐标，y轴为y坐标）
        function init2dChart() {
            const ctx = document.getElementById('2d-kalman-chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '真实状态',
                            data: [],
                            backgroundColor: '#2ecc71',
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: '预测状态',
                            data: [],
                            backgroundColor: '#f39c12',
                            pointRadius: 7,
                            pointStyle: 'triangle',
                            pointHoverRadius: 9
                        },
                        {
                            label: '测量值',
                            data: [],
                            backgroundColor: '#e74c3c',
                            pointRadius: 6,
                            pointStyle: 'cross',
                            pointHoverRadius: 8
                        },
                        {
                            label: '估计状态',
                            data: [],
                            backgroundColor: '#3498db',
                            pointRadius: 8,
                            pointStyle: 'circle',
                            pointHoverRadius: 10
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { text: 'x坐标', display: true },
                            min: -10, max: 10, ticks: { stepSize: 2 }
                        },
                        y: {
                            title: { text: 'y坐标', display: true },
                            min: -10, max: 10, ticks: { stepSize: 2 }
                        }
                    },
                    animation: { duration: 600 },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const point = context.raw;
                                    return `${context.dataset.label}: (${point.x.toFixed(2)}, ${point.y.toFixed(2)})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // 初始化 Pk 和 ek 的折线图
        function initPlotChart() {
            const ctx = document.getElementById('plot-chart').getContext('2d');
            plotChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: stepLabels,
                    datasets: [
                        {
                            label: 'P_k (估计误差方差)',
                            data: pHistory,
                            borderColor: '#8e44ad',
                            backgroundColor: 'rgba(142,68,173,0.08)',
                            yAxisID: 'yP',
                            tension: 0.2,
                            pointRadius: 3,
                        }
                        // {
                        //     label: 'e_k (创新残差范数)',
                        //     data: dxHistory,
                        //     borderColor: '#e67e22',
                        //     backgroundColor: 'rgba(230,126,34,0.08)',
                        //     yAxisID: 'yE',
                        //     tension: 0.2,
                        //     pointRadius: 3,
                        // }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: '循环次数 (k)' } },
                        yP: { type: 'linear', position: 'left', title: { display: true, text: 'P_k' } },
                        yE: { type: 'linear', position: 'right', title: { display: true, text: 'e_k' }, grid: { drawOnChartArea: false } }
                    },
                    plugins: { legend: { position: 'top' } }
                }
            });
        }

        // 3. 辅助函数：添加计算过程到右侧面板
        function addCalcStep(title, formula, result) {
            const calcContent = document.getElementById('calc-content');
            const stepDiv = document.createElement('div');
            stepDiv.className = 'calc-step';
            stepDiv.innerHTML = `
            <strong>${title}</strong>
            <div class="calc-formula">${formula}</div>
            <div>${result}</div>
            `;
            calcContent.insertBefore(stepDiv, calcContent.firstChild);
            // typeset LaTeX (if MathJax loaded)
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([stepDiv]).catch(function (err) {
                    console.warn('MathJax typeset failed: ', err);
                });
            }
            // 滚动到底部
            calcContent.scrollTop = calcContent.scrollHeight;
        }

        // 4. 步骤1：初始化系统
        function initSystem() {
            // 读取参数
            processNoise = parseFloat(document.getElementById('q-input').value);
            measureNoise = parseFloat(document.getElementById('r-input').value);
            errorCovariance = parseFloat(document.getElementById('p0-input').value);

            // 初始化二维真实状态（-5到5随机位置）
            trueState.x = circleRadius * Math.cos(circleAngle);
            trueState.y = circleRadius * Math.sin(circleAngle);
            // 初始估计状态设为原点 (0,0)
            estimatedState.x = circleRadius * Math.cos(circleAngle);
            estimatedState.y = circleRadius * Math.sin(circleAngle);

            // 重置历史数据
            trueStates = [JSON.parse(JSON.stringify(trueState))];
            estimates = [JSON.parse(JSON.stringify(estimatedState))];
            predictions = [null]; // 初始无预测
            measurements = [null]; // 初始无测量
            // Pk/ek 历史重置
            pHistory = [];
            // dxHistory = [];
            stepLabels = [];
            cycleIndex = 0;
            // 将初始 P0 作为 k=0 的值显示
            pHistory.push(errorCovariance);
            // dxHistory.push(0);
            stepLabels.push('0');

            // 更新图表
            updateChart();

            // 更新计算面板
            document.getElementById('calc-content').innerHTML = '';
            addCalcStep(
                '步骤1：初始化参数与状态',
                '\\(\\text{初始化：}\\ \\hat{x}_0 = (0,0),\\ P_0 = \\text{输入值}\\)',
                `\\(x = (${trueState.x.toFixed(2)}, ${trueState.y.toFixed(2)})\\) | \\(\\hat{x}_0 = (0.00, 0.00)\\) |  \\(P_0 = ${errorCovariance.toFixed(2)}\\)`
            );

            // 更新界面状态
            updateStepIndicator('2. 预测二维状态');
            currentStep = 1;
            setBtnState(false, true, false, false);
            // 确保 plotChart 初始化并更新显示
            if (!plotChart) initPlotChart();
            updatePlotChart();
        }

        // 步骤2：预测二维状态（卡尔曼预测方程）
        function predictState() {
            processNoise = parseFloat(document.getElementById('q-input').value) || 0.05;

            // 生成新的预测状态（A=I，x̂ₖ⁻ = x̂ₖ₋₁）
            const predictedState = JSON.parse(JSON.stringify(estimatedState));
            // 预测误差方差（Pₖ⁻ = Pₖ₋₁ + Q，因A=I）
            const predictedP = errorCovariance + processNoise;

            predictions.push(predictedState);
            estimates.push(null); // 暂存空值，更新时替换
            measurements.push(null);

            // 生成新的真实状态：沿圆周运动（角度增加）
            circleAngle += angularSpeed;
            const newTrueState = {
                x: circleRadius * Math.cos(circleAngle),
                y: circleRadius * Math.sin(circleAngle)
            };

            // 更新历史数据
            trueState = newTrueState;
            trueStates.push(JSON.parse(JSON.stringify(trueState)));

            // 更新计算面板
            addCalcStep(
                '步骤2：预测二维状态',
                '\\(\\text{预测：}\\ \\begin{aligned} \\hat{x}_k^- &= \\hat{x}_{k-1},\\\\ P_k^- &= A P_{k-1}A^T + Q \\end{aligned}\\)',
                `\\(\\hat{x}_k^- = (${predictedState.x.toFixed(2)}, ${predictedState.y.toFixed(2)})\\) | \\(P_k^- = ${predictedP.toFixed(4)}\\)`
            );

            // 更新误差方差（保存预测后的P）
            errorCovariance = predictedP;

            // 更新图表与界面
            updateChart();
            updateStepIndicator('3. 生成二维测量值');
            currentStep = 2;
            setBtnState(false, false, true, false);
            // update plot display (prediction changes internal errorCovariance but we plot P after update)
            updatePlotChart();
        }

        // 步骤3：生成二维测量值（模拟传感器噪声）
        function generateMeasurement() {
            measureNoise = parseFloat(document.getElementById('r-input').value) || 0.2;

            // 测量值 = 真实状态 + 二维高斯噪声
            const measurement = {
                x: trueState.x + (Math.random() * 2 - 1) * Math.sqrt(measureNoise),
                y: trueState.y + (Math.random() * 2 - 1) * Math.sqrt(measureNoise)
            };

            // 更新历史数据
            measurements[measurements.length - 1] = measurement; // 替换空值

            // 计算创新残差（z_k - x_k^-），使用上一次 predictions 数组中的预测值
            const predictedState = predictions[predictions.length - 1] || { x: 0, y: 0 };

            // 更新计算面板
            addCalcStep(
                '步骤3：生成二维测量值',
                '\\(\\text{测量模型：}\\ z_k = x_{\\text{true}} + n,\\ n \\sim N(0, R)\\)',
                `\\(x = (${trueState.x.toFixed(2)}, ${trueState.y.toFixed(2)})\\) | \\(z_k = (${measurement.x.toFixed(2)}, ${measurement.y.toFixed(2)})\\)`
            );

            // 更新图表与界面
            updateChart();
            updateStepIndicator('4. 更新状态估计');
            currentStep = 3;
            setBtnState(false, false, false, true);
            updatePlotChart();
        }

        // 步骤4：更新二维状态估计（卡尔曼更新方程）
        function updateEstimate() {
            const predictedState = predictions[predictions.length - 1];
            const measurement = measurements[measurements.length - 1];
            const predictedP = errorCovariance;

            // 1. 计算卡尔曼增益（H=I，简化为 Kₖ = Pₖ⁻ / (Pₖ⁻ + R)）
            const kalmanGain = predictedP / (predictedP + measureNoise);

            // 2. 更新状态估计（x̂ₖ = x̂ₖ⁻ + Kₖ*(zₖ - x̂ₖ⁻)）
            const updatedState = {
                x: predictedState.x + kalmanGain * (measurement.x - predictedState.x),
                y: predictedState.y + kalmanGain * (measurement.y - predictedState.y)
            };
            const dx = updatedState.x - trueState.x;
            const dy = updatedState.y - trueState.y;
            lastResidual = Math.sqrt(dx * dx + dy * dy);

            // 3. 更新误差方差（Pₖ = (1 - Kₖ) * Pₖ⁻）
            const updatedP = (1 - kalmanGain) * predictedP;

            // 更新历史数据
            // 更新历史数据
            estimatedState = updatedState;
            estimates[estimates.length - 1] = JSON.parse(JSON.stringify(updatedState)); // 替换空值

            // 将本次更新后的 P 和之前生成的残差一起记录到历史（形成完整的 k 循环点）
            cycleIndex += 1;
            pHistory.push(updatedP);
            // dxHistory.push(lastResidual || 0);
            stepLabels.push(String(cycleIndex));

            // 更新计算面板
            addCalcStep(
                '步骤4：更新二维状态估计',
                '\\(\\text{更新：}\\ \\begin{aligned} K_k &= P_k^-H^T (H P_k^- H^T + R)^{-1},\\\\ \\hat{x}_k &= \\hat{x}_k^- + K_k (z_k - H\\hat{x}_k^-),\\\\ P_k &= (I - K_k H) P_k^- \\end{aligned}\\)',
                `\\(K_k = ${kalmanGain.toFixed(4)}\\) | \\(\\hat{x}_k = (${updatedState.x.toFixed(2)}, ${updatedState.y.toFixed(2)})\\) | \\(P_k = ${updatedP.toFixed(4)}\\)`
            );

            // 更新误差方差
            errorCovariance = updatedP;

            // 更新图表与界面
            updateChart();
            updatePlotChart();

            // 完成一次完整循环，设置为可再次预测（循环演示）
            updateStepIndicator('2. 预测二维状态');
            currentStep = 1;
            setBtnState(false, true, false, false);
        }

        // 更新图表显示函数
        function updateChart() {
            if (!chart) return;

            // 数据集对应顺序：真实、预测、测量、估计
            const trueData = trueStates.map(p => ({ x: p.x, y: p.y }));
            const predData = predictions.filter(p => p).map(p => ({ x: p.x, y: p.y }));
            const measData = measurements.filter(m => m).map(m => ({ x: m.x, y: m.y }));
            const estData = estimates.filter(e => e).map(e => ({ x: e.x, y: e.y }));

            chart.data.datasets[0].data = trueData;
            chart.data.datasets[1].data = predData;
            chart.data.datasets[2].data = measData;
            chart.data.datasets[3].data = estData;

            chart.update();
        }

        // 更新 Pk/ek 折线图数据并刷新
        function updatePlotChart() {
            if (!plotChart) return;
            plotChart.data.labels = stepLabels.slice();
            plotChart.data.datasets[0].data = pHistory.slice();
            // plotChart.data.datasets[1].data = dxHistory.slice();
            plotChart.update();
        }

        // 更新按钮启用/禁用状态与样式
        function setBtnState(initDisabled, predictEnabled, measureEnabled, updateEnabled) {
            const initBtn = document.getElementById('init-btn');
            const predictBtn = document.getElementById('predict-btn');
            const measureBtn = document.getElementById('measure-btn');
            const updateBtn = document.getElementById('update-btn');

            initBtn.disabled = initDisabled;
            predictBtn.disabled = !predictEnabled;
            measureBtn.disabled = !measureEnabled;
            updateBtn.disabled = !updateEnabled;

            // class toggles
            predictBtn.classList.toggle('btn-disabled', !predictEnabled);
            measureBtn.classList.toggle('btn-disabled', !measureEnabled);
            updateBtn.classList.toggle('btn-disabled', !updateEnabled);
        }

        function updateStepIndicator(text) {
            document.getElementById('step-indicator').innerText = `当前步骤：${text}`;
        }

        // 重置系统到初始状态
        function resetSystem() {
            trueState = { x: 0, y: 0 };
            estimatedState = { x: 0, y: 0 };
            errorCovariance = parseFloat(document.getElementById('p0-input').value) || 1;
            processNoise = parseFloat(document.getElementById('q-input').value) || 0.05;
            measureNoise = parseFloat(document.getElementById('r-input').value) || 0.2;

            trueStates = [];
            predictions = [];
            measurements = [];
            estimates = [];

            // 清空计算面板并显示初始说明（改进公式展示，使用 LaTeX）
            document.getElementById('calc-content').innerHTML = '\n                <p>点击「1. 初始化系统」开始演示。每步会展示简洁、可读的卡尔曼滤波计算公式及对应的数值结果（本示例将 A=I₂、H=I₂ 简化为单位矩阵）。</p>\n               <div class="calc-formula">\\[\\hat{x}_k^- = A\\hat{x}_{k-1}\\]\\[P_k^- = A P_{k-1} A^T + Q\\]</div>\n     <div class="calc-formula">\\[K_k = P_k^- H^T (H P_k^- H^T + R)^{-1}\\]\\[\\hat{x}_k = \\hat{x}_k^- + K_k (z_k - H\\hat{x}_k^-)\\]\\[P_k = (I - K_k H) P_k^-\\]</div>';

            updateChart();
            // typeset the injected LaTeX
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([document.getElementById('calc-content')]).catch(function (err) {
                    console.warn('MathJax typeset failed on reset: ', err);
                });
            }
            updateStepIndicator('1. 初始化参数与系统真实状态');
            currentStep = 0;
            setBtnState(false, false, false, false);
        }

        // 事件绑定
        document.getElementById('init-btn').addEventListener('click', () => initSystem());
        document.getElementById('predict-btn').addEventListener('click', () => {
            if (currentStep === 1) predictState();
        });
        document.getElementById('measure-btn').addEventListener('click', () => {
            if (currentStep === 2) generateMeasurement();
        });
        document.getElementById('update-btn').addEventListener('click', () => {
            if (currentStep === 3) updateEstimate();
        });
        document.getElementById('reset-btn').addEventListener('click', () => resetSystem());

        // 页面加载时初始化图表与初始状态
        window.addEventListener('load', () => {
            init2dChart();
            resetSystem();
        });

    </script>
</body>

</html>