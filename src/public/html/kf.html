<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>äºŒç»´å¡å°”æ›¼æ»¤æ³¢å™¨</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)'], ['$', '$']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 3fr 2fr;
            gap: 20px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-container {
            height: 450px;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
        }

        .plot-canvas {
            height: 220px;
            margin-top: 12px;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 14px;
        }

        .btn-init {
            background: #4285f4;
            color: white;
        }

        .btn-step {
            background: #2ecc71;
            color: white;
        }

        .btn-reset {
            background: #ea4335;
            color: white;
        }

        .btn-disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #step-indicator {
            font-size: 18px;
            font-weight: bold;
            color: #4285f4;
            margin: 10px 0;
        }

        .param-panel {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
        }

        .param-group {
            margin: 15px 0;
        }

        .param-item {
            margin: 8px 0;
        }

        .calc-panel {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            height: calc(100% - 32px);
            overflow-y: auto;
        }

        .calc-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .calc-step {
            margin: 12px 0;
            padding-left: 10px;
            border-left: 3px solid #4285f4;
        }

        .calc-formula {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 8px 0;
        }

        .state-label {
            display: inline-block;
            width: 80px;
        }
    </style>
</head>

<body>
    <h1>äºŒç»´å¡å°”æ›¼æ»¤æ³¢å™¨</h1>
    <div id="step-indicator">å½“å‰æ­¥éª¤ï¼š1. åˆå§‹åŒ–å‚æ•°ä¸ç³»ç»ŸçœŸå®çŠ¶æ€</div>

    <div class="container">
        <!-- å·¦ä¾§ï¼šæ§åˆ¶åŒº + å¯è§†åŒ–å›¾è¡¨ -->
        <div class="left-panel">
            <!-- æ§åˆ¶æŒ‰é’® -->
            <div>
                <button id="init-btn" class="control-btn btn-init">1. åˆå§‹åŒ–ç³»ç»Ÿ</button>
                <button id="predict-btn" class="control-btn btn-step btn-disabled" disabled>2. é¢„æµ‹äºŒç»´çŠ¶æ€</button>
                <button id="measure-btn" class="control-btn btn-step btn-disabled" disabled>3. ç”ŸæˆäºŒç»´æµ‹é‡å€¼</button>
                <button id="update-btn" class="control-btn btn-step btn-disabled" disabled>4. æ›´æ–°çŠ¶æ€ä¼°è®¡</button>
                <button id="reset-btn" class="control-btn btn-reset">é‡ç½®æ¼”ç¤º</button>
            </div>

            <!-- å‚æ•°è°ƒèŠ‚åŒº -->
            <div class="param-panel">
                <h3>æ ¸å¿ƒå‚æ•°è°ƒèŠ‚</h3>
                <div class="param-group">
                    <div class="param-item">
                        <label>è¿‡ç¨‹å™ªå£°æ–¹å·® Qï¼š</label>
                        <input type="number" id="q-input" value="0.05" step="0.01" min="0.01" max="0.5">
                        <span>ï¼ˆç³»ç»Ÿè¿åŠ¨çš„éšæœºæ‰°åŠ¨ï¼‰</span>
                    </div>
                    <div class="param-item">
                        <label>æµ‹é‡å™ªå£°æ–¹å·® Rï¼š</label>
                        <input type="number" id="r-input" value="0.01" step="0.001" min="0.01" max="1">
                        <span>ï¼ˆä¼ æ„Ÿå™¨æµ‹é‡è¯¯å·®ï¼‰</span>
                    </div>
                    <div class="param-item">
                        <label>åˆå§‹ä¼°è®¡æ–¹å·® Pâ‚€ï¼š</label>
                        <input type="number" id="p0-input" value="1.0" step="0.1" min="0.1" max="5">
                        <span>ï¼ˆåˆå§‹ä¼°è®¡çš„ä¸ç¡®å®šæ€§ï¼‰</span>
                    </div>
                </div>
            </div>

            <!-- äºŒç»´çŠ¶æ€å¯è§†åŒ–å›¾è¡¨ -->
            <div class="chart-container">
                <canvas id="2d-kalman-chart"></canvas>
                <canvas id="plot-chart" class="plot-canvas"></canvas>
            </div>
        </div>

        <!-- å³ä¾§ï¼šå®æ—¶è®¡ç®—è¿‡ç¨‹å±•ç¤º -->
        <div class="calc-panel">
            <div class="calc-title">ğŸ“ å®æ—¶è®¡ç®—è¿‡ç¨‹ï¼ˆxåæ ‡ + yåæ ‡ï¼‰</div>
            <div id="calc-content">
                <p>ç‚¹å‡»ã€Œ1. åˆå§‹åŒ–ç³»ç»Ÿã€å¼€å§‹æ¼”ç¤ºã€‚æ¯æ­¥ä¼šå±•ç¤ºç®€æ´ã€å¯è¯»çš„å¡å°”æ›¼æ»¤æ³¢è®¡ç®—å…¬å¼åŠå¯¹åº”çš„æ•°å€¼ç»“æœï¼ˆæœ¬ç¤ºä¾‹å°† \\(A=I_2ã€H=I_2\\) ç®€åŒ–ä¸ºå•ä½çŸ©é˜µï¼‰ã€‚</p>
                <div class="calc-formula">\(\text{é¢„æµ‹ (Predict):}\)
                    <br>
                    \[\hat{x}_k^- = A\hat{x}_{k-1}\]
                    <br>
                    \[P_k^- = A P_{k-1} A^T + Q\]
                </div>
                <div class="calc-formula">\(\text{æ›´æ–° (Update):}\)
                    <br>
                    \[K_k = P_k^- H^T (H P_k^- H^T + R)^{-1}\]
                    <br>
                    \[\hat{x}_k = \hat{x}_k^- + K_k (z_k - H\hat{x}_k^-)\]
                    <br>
                    \[P_k = (I - K_k H) P_k^-\]
                </div>
            </div>
        </div>
    </div>

    <script>
        // 1. å…¨å±€çŠ¶æ€å˜é‡ï¼ˆäºŒç»´ï¼šxå’Œyåæ ‡ï¼‰
        let trueState = { x: 0, y: 0 };       // ç³»ç»ŸçœŸå®çŠ¶æ€ (x,y)
        let estimatedState = { x: 0, y: 0 };  // å¡å°”æ›¼ä¼°è®¡çŠ¶æ€
        let errorCovariance = 1;              // ä¼°è®¡è¯¯å·®æ–¹å·® Pï¼ˆäºŒç»´å…±ç”¨ï¼Œç®€åŒ–ä¸ºæ ‡é‡ï¼‰
        let processNoise = 0.05;              // è¿‡ç¨‹å™ªå£°æ–¹å·® Q
        let measureNoise = 0.2;               // æµ‹é‡å™ªå£°æ–¹å·® R
        let measurements = [];                // æµ‹é‡å€¼å†å² [{x,y}, ...]
        let estimates = [];                   // ä¼°è®¡å€¼å†å² [{x,y}, ...]
        let predictions = [];                 // é¢„æµ‹å€¼å†å² [{x,y}, ...]
        let trueStates = [];                  // çœŸå®çŠ¶æ€å†å² [{x,y}, ...]
        let currentStep = 0;                  // 0-æœªåˆå§‹åŒ–ï¼Œ1-å¯é¢„æµ‹ï¼Œ2-å¯æµ‹é‡ï¼Œ3-å¯æ›´æ–°
        let chart = null;                     // å›¾è¡¨å®ä¾‹
        let plotChart = null;                 // Pk / dxk æŠ˜çº¿å›¾å®ä¾‹
        let pHistory = [];                    // P_k (post-update) å†å²
        // let dxHistory = [];                    // dx_k (innovation norm) å†å²
        let lastResidual = 0;                 // ä¸´æ—¶ä¿å­˜æœ€è¿‘ä¸€æ¬¡ç”Ÿæˆçš„æ®‹å·®ï¼ˆåœ¨æµ‹é‡æ­¥éª¤è®¡ç®—ï¼‰
        let stepLabels = [];                  // x è½´æ ‡ç­¾ï¼ˆæ­¥å·ï¼‰
        let cycleIndex = 0;                   // å®Œæ•´å¾ªç¯è®¡æ•°ï¼ˆæ¯æ¬¡updateå+1ï¼‰
        // åœ†è½¨è¿¹å‚æ•°ï¼ˆçœŸå®çŠ¶æ€æ²¿åœ†è¿åŠ¨ï¼‰
        let circleAngle = 0;                  // å½“å‰è§’åº¦ï¼ˆå¼§åº¦ï¼‰
        let circleRadius = 6;                 // åœ†åŠå¾„
        let angularSpeed = Math.PI / 18;      // æ¯æ¬¡é¢„æµ‹è§’åº¦å¢é‡ï¼ˆå¼§åº¦ï¼‰ï¼Œé»˜è®¤ä¸º10åº¦

        // 2. åˆå§‹åŒ–äºŒç»´æ•£ç‚¹å›¾ï¼ˆxè½´ä¸ºxåæ ‡ï¼Œyè½´ä¸ºyåæ ‡ï¼‰
        function init2dChart() {
            const ctx = document.getElementById('2d-kalman-chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'çœŸå®çŠ¶æ€',
                            data: [],
                            backgroundColor: '#2ecc71',
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'é¢„æµ‹çŠ¶æ€',
                            data: [],
                            backgroundColor: '#f39c12',
                            pointRadius: 7,
                            pointStyle: 'triangle',
                            pointHoverRadius: 9
                        },
                        {
                            label: 'æµ‹é‡å€¼',
                            data: [],
                            backgroundColor: '#e74c3c',
                            pointRadius: 6,
                            pointStyle: 'cross',
                            pointHoverRadius: 8
                        },
                        {
                            label: 'ä¼°è®¡çŠ¶æ€',
                            data: [],
                            backgroundColor: '#3498db',
                            pointRadius: 8,
                            pointStyle: 'circle',
                            pointHoverRadius: 10
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { text: 'xåæ ‡', display: true },
                            min: -10, max: 10, ticks: { stepSize: 2 }
                        },
                        y: {
                            title: { text: 'yåæ ‡', display: true },
                            min: -10, max: 10, ticks: { stepSize: 2 }
                        }
                    },
                    animation: { duration: 600 },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const point = context.raw;
                                    return `${context.dataset.label}: (${point.x.toFixed(2)}, ${point.y.toFixed(2)})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // åˆå§‹åŒ– Pk å’Œ ek çš„æŠ˜çº¿å›¾
        function initPlotChart() {
            const ctx = document.getElementById('plot-chart').getContext('2d');
            plotChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: stepLabels,
                    datasets: [
                        {
                            label: 'P_k (ä¼°è®¡è¯¯å·®æ–¹å·®)',
                            data: pHistory,
                            borderColor: '#8e44ad',
                            backgroundColor: 'rgba(142,68,173,0.08)',
                            yAxisID: 'yP',
                            tension: 0.2,
                            pointRadius: 3,
                        }
                        // {
                        //     label: 'e_k (åˆ›æ–°æ®‹å·®èŒƒæ•°)',
                        //     data: dxHistory,
                        //     borderColor: '#e67e22',
                        //     backgroundColor: 'rgba(230,126,34,0.08)',
                        //     yAxisID: 'yE',
                        //     tension: 0.2,
                        //     pointRadius: 3,
                        // }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'å¾ªç¯æ¬¡æ•° (k)' } },
                        yP: { type: 'linear', position: 'left', title: { display: true, text: 'P_k' } },
                        yE: { type: 'linear', position: 'right', title: { display: true, text: 'e_k' }, grid: { drawOnChartArea: false } }
                    },
                    plugins: { legend: { position: 'top' } }
                }
            });
        }

        // 3. è¾…åŠ©å‡½æ•°ï¼šæ·»åŠ è®¡ç®—è¿‡ç¨‹åˆ°å³ä¾§é¢æ¿
        function addCalcStep(title, formula, result) {
            const calcContent = document.getElementById('calc-content');
            const stepDiv = document.createElement('div');
            stepDiv.className = 'calc-step';
            stepDiv.innerHTML = `
            <strong>${title}</strong>
            <div class="calc-formula">${formula}</div>
            <div>${result}</div>
            `;
            calcContent.insertBefore(stepDiv, calcContent.firstChild);
            // typeset LaTeX (if MathJax loaded)
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([stepDiv]).catch(function (err) {
                    console.warn('MathJax typeset failed: ', err);
                });
            }
            // æ»šåŠ¨åˆ°åº•éƒ¨
            calcContent.scrollTop = calcContent.scrollHeight;
        }

        // 4. æ­¥éª¤1ï¼šåˆå§‹åŒ–ç³»ç»Ÿ
        function initSystem() {
            // è¯»å–å‚æ•°
            processNoise = parseFloat(document.getElementById('q-input').value);
            measureNoise = parseFloat(document.getElementById('r-input').value);
            errorCovariance = parseFloat(document.getElementById('p0-input').value);

            // åˆå§‹åŒ–äºŒç»´çœŸå®çŠ¶æ€ï¼ˆ-5åˆ°5éšæœºä½ç½®ï¼‰
            trueState.x = circleRadius * Math.cos(circleAngle);
            trueState.y = circleRadius * Math.sin(circleAngle);
            // åˆå§‹ä¼°è®¡çŠ¶æ€è®¾ä¸ºåŸç‚¹ (0,0)
            estimatedState.x = circleRadius * Math.cos(circleAngle);
            estimatedState.y = circleRadius * Math.sin(circleAngle);

            // é‡ç½®å†å²æ•°æ®
            trueStates = [JSON.parse(JSON.stringify(trueState))];
            estimates = [JSON.parse(JSON.stringify(estimatedState))];
            predictions = [null]; // åˆå§‹æ— é¢„æµ‹
            measurements = [null]; // åˆå§‹æ— æµ‹é‡
            // Pk/ek å†å²é‡ç½®
            pHistory = [];
            // dxHistory = [];
            stepLabels = [];
            cycleIndex = 0;
            // å°†åˆå§‹ P0 ä½œä¸º k=0 çš„å€¼æ˜¾ç¤º
            pHistory.push(errorCovariance);
            // dxHistory.push(0);
            stepLabels.push('0');

            // æ›´æ–°å›¾è¡¨
            updateChart();

            // æ›´æ–°è®¡ç®—é¢æ¿
            document.getElementById('calc-content').innerHTML = '';
            addCalcStep(
                'æ­¥éª¤1ï¼šåˆå§‹åŒ–å‚æ•°ä¸çŠ¶æ€',
                '\\(\\text{åˆå§‹åŒ–ï¼š}\\ \\hat{x}_0 = (0,0),\\ P_0 = \\text{è¾“å…¥å€¼}\\)',
                `\\(x = (${trueState.x.toFixed(2)}, ${trueState.y.toFixed(2)})\\) | \\(\\hat{x}_0 = (0.00, 0.00)\\) |  \\(P_0 = ${errorCovariance.toFixed(2)}\\)`
            );

            // æ›´æ–°ç•Œé¢çŠ¶æ€
            updateStepIndicator('2. é¢„æµ‹äºŒç»´çŠ¶æ€');
            currentStep = 1;
            setBtnState(false, true, false, false);
            // ç¡®ä¿ plotChart åˆå§‹åŒ–å¹¶æ›´æ–°æ˜¾ç¤º
            if (!plotChart) initPlotChart();
            updatePlotChart();
        }

        // æ­¥éª¤2ï¼šé¢„æµ‹äºŒç»´çŠ¶æ€ï¼ˆå¡å°”æ›¼é¢„æµ‹æ–¹ç¨‹ï¼‰
        function predictState() {
            processNoise = parseFloat(document.getElementById('q-input').value) || 0.05;

            // ç”Ÿæˆæ–°çš„é¢„æµ‹çŠ¶æ€ï¼ˆA=Iï¼ŒxÌ‚â‚–â» = xÌ‚â‚–â‚‹â‚ï¼‰
            const predictedState = JSON.parse(JSON.stringify(estimatedState));
            // é¢„æµ‹è¯¯å·®æ–¹å·®ï¼ˆPâ‚–â» = Pâ‚–â‚‹â‚ + Qï¼Œå› A=Iï¼‰
            const predictedP = errorCovariance + processNoise;

            predictions.push(predictedState);
            estimates.push(null); // æš‚å­˜ç©ºå€¼ï¼Œæ›´æ–°æ—¶æ›¿æ¢
            measurements.push(null);

            // ç”Ÿæˆæ–°çš„çœŸå®çŠ¶æ€ï¼šæ²¿åœ†å‘¨è¿åŠ¨ï¼ˆè§’åº¦å¢åŠ ï¼‰
            circleAngle += angularSpeed;
            const newTrueState = {
                x: circleRadius * Math.cos(circleAngle),
                y: circleRadius * Math.sin(circleAngle)
            };

            // æ›´æ–°å†å²æ•°æ®
            trueState = newTrueState;
            trueStates.push(JSON.parse(JSON.stringify(trueState)));

            // æ›´æ–°è®¡ç®—é¢æ¿
            addCalcStep(
                'æ­¥éª¤2ï¼šé¢„æµ‹äºŒç»´çŠ¶æ€',
                '\\(\\text{é¢„æµ‹ï¼š}\\ \\begin{aligned} \\hat{x}_k^- &= \\hat{x}_{k-1},\\\\ P_k^- &= A P_{k-1}A^T + Q \\end{aligned}\\)',
                `\\(\\hat{x}_k^- = (${predictedState.x.toFixed(2)}, ${predictedState.y.toFixed(2)})\\) | \\(P_k^- = ${predictedP.toFixed(4)}\\)`
            );

            // æ›´æ–°è¯¯å·®æ–¹å·®ï¼ˆä¿å­˜é¢„æµ‹åçš„Pï¼‰
            errorCovariance = predictedP;

            // æ›´æ–°å›¾è¡¨ä¸ç•Œé¢
            updateChart();
            updateStepIndicator('3. ç”ŸæˆäºŒç»´æµ‹é‡å€¼');
            currentStep = 2;
            setBtnState(false, false, true, false);
            // update plot display (prediction changes internal errorCovariance but we plot P after update)
            updatePlotChart();
        }

        // æ­¥éª¤3ï¼šç”ŸæˆäºŒç»´æµ‹é‡å€¼ï¼ˆæ¨¡æ‹Ÿä¼ æ„Ÿå™¨å™ªå£°ï¼‰
        function generateMeasurement() {
            measureNoise = parseFloat(document.getElementById('r-input').value) || 0.2;

            // æµ‹é‡å€¼ = çœŸå®çŠ¶æ€ + äºŒç»´é«˜æ–¯å™ªå£°
            const measurement = {
                x: trueState.x + (Math.random() * 2 - 1) * Math.sqrt(measureNoise),
                y: trueState.y + (Math.random() * 2 - 1) * Math.sqrt(measureNoise)
            };

            // æ›´æ–°å†å²æ•°æ®
            measurements[measurements.length - 1] = measurement; // æ›¿æ¢ç©ºå€¼

            // è®¡ç®—åˆ›æ–°æ®‹å·®ï¼ˆz_k - x_k^-ï¼‰ï¼Œä½¿ç”¨ä¸Šä¸€æ¬¡ predictions æ•°ç»„ä¸­çš„é¢„æµ‹å€¼
            const predictedState = predictions[predictions.length - 1] || { x: 0, y: 0 };

            // æ›´æ–°è®¡ç®—é¢æ¿
            addCalcStep(
                'æ­¥éª¤3ï¼šç”ŸæˆäºŒç»´æµ‹é‡å€¼',
                '\\(\\text{æµ‹é‡æ¨¡å‹ï¼š}\\ z_k = x_{\\text{true}} + n,\\ n \\sim N(0, R)\\)',
                `\\(x = (${trueState.x.toFixed(2)}, ${trueState.y.toFixed(2)})\\) | \\(z_k = (${measurement.x.toFixed(2)}, ${measurement.y.toFixed(2)})\\)`
            );

            // æ›´æ–°å›¾è¡¨ä¸ç•Œé¢
            updateChart();
            updateStepIndicator('4. æ›´æ–°çŠ¶æ€ä¼°è®¡');
            currentStep = 3;
            setBtnState(false, false, false, true);
            updatePlotChart();
        }

        // æ­¥éª¤4ï¼šæ›´æ–°äºŒç»´çŠ¶æ€ä¼°è®¡ï¼ˆå¡å°”æ›¼æ›´æ–°æ–¹ç¨‹ï¼‰
        function updateEstimate() {
            const predictedState = predictions[predictions.length - 1];
            const measurement = measurements[measurements.length - 1];
            const predictedP = errorCovariance;

            // 1. è®¡ç®—å¡å°”æ›¼å¢ç›Šï¼ˆH=Iï¼Œç®€åŒ–ä¸º Kâ‚– = Pâ‚–â» / (Pâ‚–â» + R)ï¼‰
            const kalmanGain = predictedP / (predictedP + measureNoise);

            // 2. æ›´æ–°çŠ¶æ€ä¼°è®¡ï¼ˆxÌ‚â‚– = xÌ‚â‚–â» + Kâ‚–*(zâ‚– - xÌ‚â‚–â»)ï¼‰
            const updatedState = {
                x: predictedState.x + kalmanGain * (measurement.x - predictedState.x),
                y: predictedState.y + kalmanGain * (measurement.y - predictedState.y)
            };
            const dx = updatedState.x - trueState.x;
            const dy = updatedState.y - trueState.y;
            lastResidual = Math.sqrt(dx * dx + dy * dy);

            // 3. æ›´æ–°è¯¯å·®æ–¹å·®ï¼ˆPâ‚– = (1 - Kâ‚–) * Pâ‚–â»ï¼‰
            const updatedP = (1 - kalmanGain) * predictedP;

            // æ›´æ–°å†å²æ•°æ®
            // æ›´æ–°å†å²æ•°æ®
            estimatedState = updatedState;
            estimates[estimates.length - 1] = JSON.parse(JSON.stringify(updatedState)); // æ›¿æ¢ç©ºå€¼

            // å°†æœ¬æ¬¡æ›´æ–°åçš„ P å’Œä¹‹å‰ç”Ÿæˆçš„æ®‹å·®ä¸€èµ·è®°å½•åˆ°å†å²ï¼ˆå½¢æˆå®Œæ•´çš„ k å¾ªç¯ç‚¹ï¼‰
            cycleIndex += 1;
            pHistory.push(updatedP);
            // dxHistory.push(lastResidual || 0);
            stepLabels.push(String(cycleIndex));

            // æ›´æ–°è®¡ç®—é¢æ¿
            addCalcStep(
                'æ­¥éª¤4ï¼šæ›´æ–°äºŒç»´çŠ¶æ€ä¼°è®¡',
                '\\(\\text{æ›´æ–°ï¼š}\\ \\begin{aligned} K_k &= P_k^-H^T (H P_k^- H^T + R)^{-1},\\\\ \\hat{x}_k &= \\hat{x}_k^- + K_k (z_k - H\\hat{x}_k^-),\\\\ P_k &= (I - K_k H) P_k^- \\end{aligned}\\)',
                `\\(K_k = ${kalmanGain.toFixed(4)}\\) | \\(\\hat{x}_k = (${updatedState.x.toFixed(2)}, ${updatedState.y.toFixed(2)})\\) | \\(P_k = ${updatedP.toFixed(4)}\\)`
            );

            // æ›´æ–°è¯¯å·®æ–¹å·®
            errorCovariance = updatedP;

            // æ›´æ–°å›¾è¡¨ä¸ç•Œé¢
            updateChart();
            updatePlotChart();

            // å®Œæˆä¸€æ¬¡å®Œæ•´å¾ªç¯ï¼Œè®¾ç½®ä¸ºå¯å†æ¬¡é¢„æµ‹ï¼ˆå¾ªç¯æ¼”ç¤ºï¼‰
            updateStepIndicator('2. é¢„æµ‹äºŒç»´çŠ¶æ€');
            currentStep = 1;
            setBtnState(false, true, false, false);
        }

        // æ›´æ–°å›¾è¡¨æ˜¾ç¤ºå‡½æ•°
        function updateChart() {
            if (!chart) return;

            // æ•°æ®é›†å¯¹åº”é¡ºåºï¼šçœŸå®ã€é¢„æµ‹ã€æµ‹é‡ã€ä¼°è®¡
            const trueData = trueStates.map(p => ({ x: p.x, y: p.y }));
            const predData = predictions.filter(p => p).map(p => ({ x: p.x, y: p.y }));
            const measData = measurements.filter(m => m).map(m => ({ x: m.x, y: m.y }));
            const estData = estimates.filter(e => e).map(e => ({ x: e.x, y: e.y }));

            chart.data.datasets[0].data = trueData;
            chart.data.datasets[1].data = predData;
            chart.data.datasets[2].data = measData;
            chart.data.datasets[3].data = estData;

            chart.update();
        }

        // æ›´æ–° Pk/ek æŠ˜çº¿å›¾æ•°æ®å¹¶åˆ·æ–°
        function updatePlotChart() {
            if (!plotChart) return;
            plotChart.data.labels = stepLabels.slice();
            plotChart.data.datasets[0].data = pHistory.slice();
            // plotChart.data.datasets[1].data = dxHistory.slice();
            plotChart.update();
        }

        // æ›´æ–°æŒ‰é’®å¯ç”¨/ç¦ç”¨çŠ¶æ€ä¸æ ·å¼
        function setBtnState(initDisabled, predictEnabled, measureEnabled, updateEnabled) {
            const initBtn = document.getElementById('init-btn');
            const predictBtn = document.getElementById('predict-btn');
            const measureBtn = document.getElementById('measure-btn');
            const updateBtn = document.getElementById('update-btn');

            initBtn.disabled = initDisabled;
            predictBtn.disabled = !predictEnabled;
            measureBtn.disabled = !measureEnabled;
            updateBtn.disabled = !updateEnabled;

            // class toggles
            predictBtn.classList.toggle('btn-disabled', !predictEnabled);
            measureBtn.classList.toggle('btn-disabled', !measureEnabled);
            updateBtn.classList.toggle('btn-disabled', !updateEnabled);
        }

        function updateStepIndicator(text) {
            document.getElementById('step-indicator').innerText = `å½“å‰æ­¥éª¤ï¼š${text}`;
        }

        // é‡ç½®ç³»ç»Ÿåˆ°åˆå§‹çŠ¶æ€
        function resetSystem() {
            trueState = { x: 0, y: 0 };
            estimatedState = { x: 0, y: 0 };
            errorCovariance = parseFloat(document.getElementById('p0-input').value) || 1;
            processNoise = parseFloat(document.getElementById('q-input').value) || 0.05;
            measureNoise = parseFloat(document.getElementById('r-input').value) || 0.2;

            trueStates = [];
            predictions = [];
            measurements = [];
            estimates = [];

            // æ¸…ç©ºè®¡ç®—é¢æ¿å¹¶æ˜¾ç¤ºåˆå§‹è¯´æ˜ï¼ˆæ”¹è¿›å…¬å¼å±•ç¤ºï¼Œä½¿ç”¨ LaTeXï¼‰
            document.getElementById('calc-content').innerHTML = '\n                <p>ç‚¹å‡»ã€Œ1. åˆå§‹åŒ–ç³»ç»Ÿã€å¼€å§‹æ¼”ç¤ºã€‚æ¯æ­¥ä¼šå±•ç¤ºç®€æ´ã€å¯è¯»çš„å¡å°”æ›¼æ»¤æ³¢è®¡ç®—å…¬å¼åŠå¯¹åº”çš„æ•°å€¼ç»“æœï¼ˆæœ¬ç¤ºä¾‹å°† A=Iâ‚‚ã€H=Iâ‚‚ ç®€åŒ–ä¸ºå•ä½çŸ©é˜µï¼‰ã€‚</p>\n               <div class="calc-formula">\\[\\hat{x}_k^- = A\\hat{x}_{k-1}\\]\\[P_k^- = A P_{k-1} A^T + Q\\]</div>\n     <div class="calc-formula">\\[K_k = P_k^- H^T (H P_k^- H^T + R)^{-1}\\]\\[\\hat{x}_k = \\hat{x}_k^- + K_k (z_k - H\\hat{x}_k^-)\\]\\[P_k = (I - K_k H) P_k^-\\]</div>';

            updateChart();
            // typeset the injected LaTeX
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([document.getElementById('calc-content')]).catch(function (err) {
                    console.warn('MathJax typeset failed on reset: ', err);
                });
            }
            updateStepIndicator('1. åˆå§‹åŒ–å‚æ•°ä¸ç³»ç»ŸçœŸå®çŠ¶æ€');
            currentStep = 0;
            setBtnState(false, false, false, false);
        }

        // äº‹ä»¶ç»‘å®š
        document.getElementById('init-btn').addEventListener('click', () => initSystem());
        document.getElementById('predict-btn').addEventListener('click', () => {
            if (currentStep === 1) predictState();
        });
        document.getElementById('measure-btn').addEventListener('click', () => {
            if (currentStep === 2) generateMeasurement();
        });
        document.getElementById('update-btn').addEventListener('click', () => {
            if (currentStep === 3) updateEstimate();
        });
        document.getElementById('reset-btn').addEventListener('click', () => resetSystem());

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–å›¾è¡¨ä¸åˆå§‹çŠ¶æ€
        window.addEventListener('load', () => {
            init2dChart();
            resetSystem();
        });

    </script>
</body>

</html>